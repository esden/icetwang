# ! [doc = "Peripheral access API for ICETWANG-SOC microcontrollers (generated using svd2rust v0.17.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.17.0/svd2rust/#peripheral-api"]
# ! [deny (const_err)]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
extern crate riscv ; # [cfg (feature = "rt")]
extern crate riscv_rt ; extern crate bare_metal ; extern crate vcell ; use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = "This trait shows that register has `read` method"]
# [doc = ""]
# [doc = "Registers marked with `Writable` can be also `modify`'ed"]
pub trait Readable { } # [doc = "This trait shows that register has `write`, `write_with_zero` and `reset` method"]
# [doc = ""]
# [doc = "Registers marked with `Readable` can be also `modify`'ed"]
pub trait Writable { } # [doc = "Reset value of the register"]
# [doc = ""]
# [doc = "This value is initial value for `write` method."]
# [doc = "It can be also directly writed to register by `reset` method."]
pub trait ResetValue { # [doc = "Register size"]
type Type ; # [doc = "Reset value of the register"]
fn reset_value () -> Self :: Type ; } # [doc = "This structure provides volatile access to register"]
pub struct Reg < U , REG > { register : vcell :: VolatileCell < U > , _marker : marker :: PhantomData < REG > , } unsafe impl < U : Send , REG > Send for Reg < U , REG > { } impl < U , REG > Reg < U , REG > where Self : Readable , U : Copy { # [doc = "Reads the contents of `Readable` register"]
# [doc = ""]
# [doc = "You can read the contents of a register in such way:"]
# [doc = "```ignore"]
# [doc = "let bits = periph.reg.read().bits();"]
# [doc = "```"]
# [doc = "or get the content of a particular field of a register."]
# [doc = "```ignore"]
# [doc = "let reader = periph.reg.read();"]
# [doc = "let bits = reader.field1().bits();"]
# [doc = "let flag = reader.field2().bit_is_set();"]
# [doc = "```"]
# [inline (always)]
pub fn read (& self) -> R < U , Self > { R { bits : self . register . get () , _reg : marker :: PhantomData } } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy , { # [doc = "Writes the reset value to `Writable` register"]
# [doc = ""]
# [doc = "Resets the register to its initial state"]
# [inline (always)]
pub fn reset (& self) { self . register . set (Self :: reset_value ()) } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy { # [doc = "Writes bits to `Writable` register"]
# [doc = ""]
# [doc = "You can write raw bits into a register:"]
# [doc = "```ignore"]
# [doc = "periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = "```"]
# [doc = "or write only the fields you need:"]
# [doc = "```ignore"]
# [doc = "periph.reg.write(|w| w"]
# [doc = "    .field1().bits(newfield1bits)"]
# [doc = "    .field2().set_bit()"]
# [doc = "    .field3().variant(VARIANT)"]
# [doc = ");"]
# [doc = "```"]
# [doc = "Other fields will have reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut W < U , Self >) -> & mut W < U , Self > { self . register . set (f (& mut W { bits : Self :: reset_value () , _reg : marker :: PhantomData }) . bits) ; } } impl < U , REG > Reg < U , REG > where Self : Writable , U : Copy + Default { # [doc = "Writes Zero to `Writable` register"]
# [doc = ""]
# [doc = "Similar to `write`, but unused bits will contain 0."]
# [inline (always)]
pub fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut W < U , Self >) -> & mut W < U , Self > { self . register . set (f (& mut W { bits : U :: default () , _reg : marker :: PhantomData }) . bits) ; } } impl < U , REG > Reg < U , REG > where Self : Readable + Writable , U : Copy , { # [doc = "Modifies the contents of the register"]
# [doc = ""]
# [doc = "E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = "```ignore"]
# [doc = "periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "   r.bits() | 3"]
# [doc = ") });"]
# [doc = "```"]
# [doc = "or"]
# [doc = "```ignore"]
# [doc = "periph.reg.modify(|_, w| w"]
# [doc = "    .field1().bits(newfield1bits)"]
# [doc = "    .field2().set_bit()"]
# [doc = "    .field3().variant(VARIANT)"]
# [doc = ");"]
# [doc = "```"]
# [doc = "Other fields will have value they had before call `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& R < U , Self > , & 'w mut W < U , Self >) -> & 'w mut W < U , Self > { let bits = self . register . get () ; self . register . set (f (& R { bits , _reg : marker :: PhantomData } , & mut W { bits , _reg : marker :: PhantomData }) . bits) ; } } # [doc = "Register/field reader"]
# [doc = ""]
# [doc = "Result of the [`read`](Reg::read) method of a register."]
# [doc = "Also it can be used in the [`modify`](Reg::read) method"]
pub struct R < U , T > { pub (crate) bits : U , _reg : marker :: PhantomData < T > , } impl < U , T > R < U , T > where U : Copy { # [doc = "Create new instance of reader"]
# [inline (always)]
pub (crate) fn new (bits : U) -> Self { Self { bits , _reg : marker :: PhantomData , } } # [doc = "Read raw bits from register/field"]
# [inline (always)]
pub fn bits (& self) -> U { self . bits } } impl < U , T , FI > PartialEq < FI > for R < U , T > where U : PartialEq , FI : Copy + Into < U > { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& (* other) . into ()) } } impl < FI > R < bool , FI > { # [doc = "Value of the field as raw bits"]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = "Returns `true` if the bit is clear (0)"]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = "Returns `true` if the bit is set (1)"]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc = "Register writer"]
# [doc = ""]
# [doc = "Used as an argument to the closures in the [`write`](Reg::write) and [`modify`](Reg::modify) methods of the register"]
pub struct W < U , REG > { # [doc = "Writable bits"]
pub (crate) bits : U , _reg : marker :: PhantomData < REG > , } impl < U , REG > W < U , REG > { # [doc = "Writes raw bits to the register"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : U) -> & mut Self { self . bits = bits ; self } } # [doc = "Used if enumerated values cover not the whole range"]
# [derive (Clone , Copy , PartialEq)]
pub enum Variant < U , T > { # [doc = "Expected variant"]
Val (T) , # [doc = "Raw bits"]
Res (U) , } } # [doc = "LED control"]
pub struct LED_COMMON { _marker : PhantomData < * const () > } unsafe impl Send for LED_COMMON { } impl LED_COMMON { # [doc = r"Returns a pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const led_common :: RegisterBlock { 0x8300_0000 as * const _ } } impl Deref for LED_COMMON { type Target = led_common :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * LED_COMMON :: ptr () } } } # [doc = "LED control"]
pub mod led_common { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control and Status Register"]
pub csr : CSR , _reserved1 : [u8 ; 64usize]
, # [doc = "0x44 - Pulse Width Register Red"]
pub pwrr : PWRR , # [doc = "0x48 - Pulse Width Register Green"]
pub pwrg : PWRG , # [doc = "0x4c - Pulse Width Register Green"]
pub pwrb : PWRB , _reserved4 : [u8 ; 4usize]
, # [doc = "0x54 - Breathe Control Rise Register"]
pub bcrr : BCRR , # [doc = "0x58 - Breathe Control Fall Register"]
pub bcfr : BCFR , _reserved6 : [u8 ; 4usize]
, # [doc = "0x60 - Control Register 0"]
pub cr0 : CR0 , # [doc = "0x64 - Pre-scale Register"]
pub br : BR , # [doc = "0x68 - ON Time Register"]
pub onr : ONR , # [doc = "0x6c - OFF Time Register"]
pub ofr : OFR , } # [doc = "Control and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
pub type CSR = crate :: Reg < u32 , _CSR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _CSR ; # [doc = "`read()` method returns [csr::R](csr::R) reader structure"]
impl crate :: Readable for CSR { } # [doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
impl crate :: Writable for CSR { } # [doc = "Control and Status Register"]
pub mod csr { # [doc = "Reader of register CSR"]
pub type R = crate :: R < u32 , super :: CSR > ; # [doc = "Writer for register CSR"]
pub type W = crate :: W < u32 , super :: CSR > ; # [doc = "Register CSR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: CSR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `LEDDEXE`"]
pub type LEDDEXE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `LEDDEXE`"]
pub struct LEDDEXE_W < 'a > { w : & 'a mut W , } impl < 'a > LEDDEXE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | (((value as u32) & 0x01) << 1) ; self . w } } # [doc = "Reader of field `RGBLEDEN`"]
pub type RGBLEDEN_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `RGBLEDEN`"]
pub struct RGBLEDEN_W < 'a > { w : & 'a mut W , } impl < 'a > RGBLEDEN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | (((value as u32) & 0x01) << 2) ; self . w } } # [doc = "Reader of field `CURREN`"]
pub type CURREN_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `CURREN`"]
pub struct CURREN_W < 'a > { w : & 'a mut W , } impl < 'a > CURREN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | (((value as u32) & 0x01) << 3) ; self . w } } impl R { # [doc = "Bit 1 - Enable the IP to run the blinking sequence. When low, the sequence stops at the nearest OFF state"]
# [inline (always)]
pub fn leddexe (& self) -> LEDDEXE_R { LEDDEXE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Enable control of the RGB LED"]
# [inline (always)]
pub fn rgbleden (& self) -> RGBLEDEN_R { RGBLEDEN_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Power up"]
# [inline (always)]
pub fn curren (& self) -> CURREN_R { CURREN_R :: new (((self . bits >> 3) & 0x01) != 0) } } impl W { # [doc = "Bit 1 - Enable the IP to run the blinking sequence. When low, the sequence stops at the nearest OFF state"]
# [inline (always)]
pub fn leddexe (& mut self) -> LEDDEXE_W { LEDDEXE_W { w : self } } # [doc = "Bit 2 - Enable control of the RGB LED"]
# [inline (always)]
pub fn rgbleden (& mut self) -> RGBLEDEN_W { RGBLEDEN_W { w : self } } # [doc = "Bit 3 - Power up"]
# [inline (always)]
pub fn curren (& mut self) -> CURREN_W { CURREN_W { w : self } } } } # [doc = "Pulse Width Register Red\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pwrr](pwrr) module"]
pub type PWRR = crate :: Reg < u32 , _PWRR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _PWRR ; # [doc = "`read()` method returns [pwrr::R](pwrr::R) reader structure"]
impl crate :: Readable for PWRR { } # [doc = "`write(|w| ..)` method takes [pwrr::W](pwrr::W) writer structure"]
impl crate :: Writable for PWRR { } # [doc = "Pulse Width Register Red"]
pub mod pwrr { # [doc = "Reader of register PWRR"]
pub type R = crate :: R < u32 , super :: PWRR > ; # [doc = "Writer for register PWRR"]
pub type W = crate :: W < u32 , super :: PWRR > ; # [doc = "Register PWRR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: PWRR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "Pulse Width Register Green\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pwrg](pwrg) module"]
pub type PWRG = crate :: Reg < u32 , _PWRG > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _PWRG ; # [doc = "`read()` method returns [pwrg::R](pwrg::R) reader structure"]
impl crate :: Readable for PWRG { } # [doc = "`write(|w| ..)` method takes [pwrg::W](pwrg::W) writer structure"]
impl crate :: Writable for PWRG { } # [doc = "Pulse Width Register Green"]
pub mod pwrg { # [doc = "Reader of register PWRG"]
pub type R = crate :: R < u32 , super :: PWRG > ; # [doc = "Writer for register PWRG"]
pub type W = crate :: W < u32 , super :: PWRG > ; # [doc = "Register PWRG `reset()`'s with value 0"]
impl crate :: ResetValue for super :: PWRG { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "Pulse Width Register Green\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pwrb](pwrb) module"]
pub type PWRB = crate :: Reg < u32 , _PWRB > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _PWRB ; # [doc = "`read()` method returns [pwrb::R](pwrb::R) reader structure"]
impl crate :: Readable for PWRB { } # [doc = "`write(|w| ..)` method takes [pwrb::W](pwrb::W) writer structure"]
impl crate :: Writable for PWRB { } # [doc = "Pulse Width Register Green"]
pub mod pwrb { # [doc = "Reader of register PWRB"]
pub type R = crate :: R < u32 , super :: PWRB > ; # [doc = "Writer for register PWRB"]
pub type W = crate :: W < u32 , super :: PWRB > ; # [doc = "Register PWRB `reset()`'s with value 0"]
impl crate :: ResetValue for super :: PWRB { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "Breathe Control Rise Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bcrr](bcrr) module"]
pub type BCRR = crate :: Reg < u32 , _BCRR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _BCRR ; # [doc = "`read()` method returns [bcrr::R](bcrr::R) reader structure"]
impl crate :: Readable for BCRR { } # [doc = "`write(|w| ..)` method takes [bcrr::W](bcrr::W) writer structure"]
impl crate :: Writable for BCRR { } # [doc = "Breathe Control Rise Register"]
pub mod bcrr { # [doc = "Reader of register BCRR"]
pub type R = crate :: R < u32 , super :: BCRR > ; # [doc = "Writer for register BCRR"]
pub type W = crate :: W < u32 , super :: BCRR > ; # [doc = "Register BCRR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: BCRR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `BRATE`"]
pub type BRATE_R = crate :: R < u8 , u8 > ; # [doc = "Write proxy for field `BRATE`"]
pub struct BRATE_W < 'a > { w : & 'a mut W , } impl < 'a > BRATE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x0f) | ((value as u32) & 0x0f) ; self . w } } # [doc = "Reader of field `BMODE`"]
pub type BMODE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BMODE`"]
pub struct BMODE_W < 'a > { w : & 'a mut W , } impl < 'a > BMODE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | (((value as u32) & 0x01) << 5) ; self . w } } # [doc = "Reader of field `BEDGE`"]
pub type BEDGE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BEDGE`"]
pub struct BEDGE_W < 'a > { w : & 'a mut W , } impl < 'a > BEDGE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | (((value as u32) & 0x01) << 6) ; self . w } } # [doc = "Reader of field `BON`"]
pub type BON_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BON`"]
pub struct BON_W < 'a > { w : & 'a mut W , } impl < 'a > BON_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | (((value as u32) & 0x01) << 7) ; self . w } } impl R { # [doc = "Bits 0:3 - Breathe ON Rate"]
# [inline (always)]
pub fn brate (& self) -> BRATE_R { BRATE_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 5 - Breathe Mode Select 0= Breathe with local rate, 1= Modulate rate based on color setting"]
# [inline (always)]
pub fn bmode (& self) -> BMODE_R { BMODE_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - Breathe Edge 0= Breathe control only for ON ramp, 1= Breathe control for ON and OFF ramp"]
# [inline (always)]
pub fn bedge (& self) -> BEDGE_R { BEDGE_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Breathe ON Enable"]
# [inline (always)]
pub fn bon (& self) -> BON_R { BON_R :: new (((self . bits >> 7) & 0x01) != 0) } } impl W { # [doc = "Bits 0:3 - Breathe ON Rate"]
# [inline (always)]
pub fn brate (& mut self) -> BRATE_W { BRATE_W { w : self } } # [doc = "Bit 5 - Breathe Mode Select 0= Breathe with local rate, 1= Modulate rate based on color setting"]
# [inline (always)]
pub fn bmode (& mut self) -> BMODE_W { BMODE_W { w : self } } # [doc = "Bit 6 - Breathe Edge 0= Breathe control only for ON ramp, 1= Breathe control for ON and OFF ramp"]
# [inline (always)]
pub fn bedge (& mut self) -> BEDGE_W { BEDGE_W { w : self } } # [doc = "Bit 7 - Breathe ON Enable"]
# [inline (always)]
pub fn bon (& mut self) -> BON_W { BON_W { w : self } } } } # [doc = "Breathe Control Fall Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bcfr](bcfr) module"]
pub type BCFR = crate :: Reg < u32 , _BCFR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _BCFR ; # [doc = "`read()` method returns [bcfr::R](bcfr::R) reader structure"]
impl crate :: Readable for BCFR { } # [doc = "`write(|w| ..)` method takes [bcfr::W](bcfr::W) writer structure"]
impl crate :: Writable for BCFR { } # [doc = "Breathe Control Fall Register"]
pub mod bcfr { # [doc = "Reader of register BCFR"]
pub type R = crate :: R < u32 , super :: BCFR > ; # [doc = "Writer for register BCFR"]
pub type W = crate :: W < u32 , super :: BCFR > ; # [doc = "Register BCFR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: BCFR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `BRATE`"]
pub type BRATE_R = crate :: R < u8 , u8 > ; # [doc = "Write proxy for field `BRATE`"]
pub struct BRATE_W < 'a > { w : & 'a mut W , } impl < 'a > BRATE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x0f) | ((value as u32) & 0x0f) ; self . w } } # [doc = "Reader of field `BMODE`"]
pub type BMODE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BMODE`"]
pub struct BMODE_W < 'a > { w : & 'a mut W , } impl < 'a > BMODE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | (((value as u32) & 0x01) << 5) ; self . w } } # [doc = "Reader of field `BRANGE`"]
pub type BRANGE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BRANGE`"]
pub struct BRANGE_W < 'a > { w : & 'a mut W , } impl < 'a > BRANGE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | (((value as u32) & 0x01) << 6) ; self . w } } # [doc = "Reader of field `BON`"]
pub type BON_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BON`"]
pub struct BON_W < 'a > { w : & 'a mut W , } impl < 'a > BON_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | (((value as u32) & 0x01) << 7) ; self . w } } impl R { # [doc = "Bits 0:3 - Breathe OFF Rate"]
# [inline (always)]
pub fn brate (& self) -> BRATE_R { BRATE_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 5 - Breathe Mode Select 0= Breathe with local rate, 1= Modulate rate based on color setting"]
# [inline (always)]
pub fn bmode (& self) -> BMODE_R { BMODE_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - Breathe Range extend for linear mode"]
# [inline (always)]
pub fn brange (& self) -> BRANGE_R { BRANGE_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Breathe OFF Enable"]
# [inline (always)]
pub fn bon (& self) -> BON_R { BON_R :: new (((self . bits >> 7) & 0x01) != 0) } } impl W { # [doc = "Bits 0:3 - Breathe OFF Rate"]
# [inline (always)]
pub fn brate (& mut self) -> BRATE_W { BRATE_W { w : self } } # [doc = "Bit 5 - Breathe Mode Select 0= Breathe with local rate, 1= Modulate rate based on color setting"]
# [inline (always)]
pub fn bmode (& mut self) -> BMODE_W { BMODE_W { w : self } } # [doc = "Bit 6 - Breathe Range extend for linear mode"]
# [inline (always)]
pub fn brange (& mut self) -> BRANGE_W { BRANGE_W { w : self } } # [doc = "Bit 7 - Breathe OFF Enable"]
# [inline (always)]
pub fn bon (& mut self) -> BON_W { BON_W { w : self } } } } # [doc = "Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr0](cr0) module"]
pub type CR0 = crate :: Reg < u32 , _CR0 > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _CR0 ; # [doc = "`read()` method returns [cr0::R](cr0::R) reader structure"]
impl crate :: Readable for CR0 { } # [doc = "`write(|w| ..)` method takes [cr0::W](cr0::W) writer structure"]
impl crate :: Writable for CR0 { } # [doc = "Control Register 0"]
pub mod cr0 { # [doc = "Reader of register CR0"]
pub type R = crate :: R < u32 , super :: CR0 > ; # [doc = "Writer for register CR0"]
pub type W = crate :: W < u32 , super :: CR0 > ; # [doc = "Register CR0 `reset()`'s with value 0"]
impl crate :: ResetValue for super :: CR0 { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `BRMSBEXT`"]
pub type BRMSBEXT_R = crate :: R < u8 , u8 > ; # [doc = "Write proxy for field `BRMSBEXT`"]
pub struct BRMSBEXT_W < 'a > { w : & 'a mut W , } impl < 'a > BRMSBEXT_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x03) | ((value as u32) & 0x03) ; self . w } } # [doc = "Reader of field `PWM_MODE`"]
pub type PWM_MODE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `PWM_MODE`"]
pub struct PWM_MODE_W < 'a > { w : & 'a mut W , } impl < 'a > PWM_MODE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | (((value as u32) & 0x01) << 2) ; self . w } } # [doc = "Reader of field `QUICK_STOP`"]
pub type QUICK_STOP_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `QUICK_STOP`"]
pub struct QUICK_STOP_W < 'a > { w : & 'a mut W , } impl < 'a > QUICK_STOP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | (((value as u32) & 0x01) << 3) ; self . w } } # [doc = "Reader of field `OUTSKEW`"]
pub type OUTSKEW_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `OUTSKEW`"]
pub struct OUTSKEW_W < 'a > { w : & 'a mut W , } impl < 'a > OUTSKEW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | (((value as u32) & 0x01) << 4) ; self . w } } # [doc = "Reader of field `OUTPOL`"]
pub type OUTPOL_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `OUTPOL`"]
pub struct OUTPOL_W < 'a > { w : & 'a mut W , } impl < 'a > OUTPOL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | (((value as u32) & 0x01) << 5) ; self . w } } # [doc = "Reader of field `FR250`"]
pub type FR250_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `FR250`"]
pub struct FR250_W < 'a > { w : & 'a mut W , } impl < 'a > FR250_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | (((value as u32) & 0x01) << 6) ; self . w } } # [doc = "Reader of field `LEDDEN`"]
pub type LEDDEN_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `LEDDEN`"]
pub struct LEDDEN_W < 'a > { w : & 'a mut W , } impl < 'a > LEDDEN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | (((value as u32) & 0x01) << 7) ; self . w } } impl R { # [doc = "Bits 0:1 - Pre-scale register MSB extension"]
# [inline (always)]
pub fn brmsbext (& self) -> BRMSBEXT_R { BRMSBEXT_R :: new ((self . bits & 0x03) as u8) } # [doc = "Bit 2 - 0= Linear, 1= LFSR"]
# [inline (always)]
pub fn pwm_mode (& self) -> PWM_MODE_R { PWM_MODE_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - 0= Stop the blinking sequence wheen current ON period finishes, 1= Stop blinking immediately"]
# [inline (always)]
pub fn quick_stop (& self) -> QUICK_STOP_R { QUICK_STOP_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Enable PWM slew to reduce simultaneous switching noise, based on BRMSBEXT"]
# [inline (always)]
pub fn outskew (& self) -> OUTSKEW_R { OUTSKEW_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - PWM output polarity. 0= Active high, 1= Active low"]
# [inline (always)]
pub fn outpol (& self) -> OUTPOL_R { OUTPOL_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - PWM flick rate. 0= 125Hz, 1= 250Hz"]
# [inline (always)]
pub fn fr250 (& self) -> FR250_R { FR250_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - LED Driver Enable"]
# [inline (always)]
pub fn ledden (& self) -> LEDDEN_R { LEDDEN_R :: new (((self . bits >> 7) & 0x01) != 0) } } impl W { # [doc = "Bits 0:1 - Pre-scale register MSB extension"]
# [inline (always)]
pub fn brmsbext (& mut self) -> BRMSBEXT_W { BRMSBEXT_W { w : self } } # [doc = "Bit 2 - 0= Linear, 1= LFSR"]
# [inline (always)]
pub fn pwm_mode (& mut self) -> PWM_MODE_W { PWM_MODE_W { w : self } } # [doc = "Bit 3 - 0= Stop the blinking sequence wheen current ON period finishes, 1= Stop blinking immediately"]
# [inline (always)]
pub fn quick_stop (& mut self) -> QUICK_STOP_W { QUICK_STOP_W { w : self } } # [doc = "Bit 4 - Enable PWM slew to reduce simultaneous switching noise, based on BRMSBEXT"]
# [inline (always)]
pub fn outskew (& mut self) -> OUTSKEW_W { OUTSKEW_W { w : self } } # [doc = "Bit 5 - PWM output polarity. 0= Active high, 1= Active low"]
# [inline (always)]
pub fn outpol (& mut self) -> OUTPOL_W { OUTPOL_W { w : self } } # [doc = "Bit 6 - PWM flick rate. 0= 125Hz, 1= 250Hz"]
# [inline (always)]
pub fn fr250 (& mut self) -> FR250_W { FR250_W { w : self } } # [doc = "Bit 7 - LED Driver Enable"]
# [inline (always)]
pub fn ledden (& mut self) -> LEDDEN_W { LEDDEN_W { w : self } } } } # [doc = "Pre-scale Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [br](br) module"]
pub type BR = crate :: Reg < u32 , _BR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _BR ; # [doc = "`read()` method returns [br::R](br::R) reader structure"]
impl crate :: Readable for BR { } # [doc = "`write(|w| ..)` method takes [br::W](br::W) writer structure"]
impl crate :: Writable for BR { } # [doc = "Pre-scale Register"]
pub mod br { # [doc = "Reader of register BR"]
pub type R = crate :: R < u32 , super :: BR > ; # [doc = "Writer for register BR"]
pub type W = crate :: W < u32 , super :: BR > ; # [doc = "Register BR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: BR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "ON Time Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [onr](onr) module"]
pub type ONR = crate :: Reg < u32 , _ONR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _ONR ; # [doc = "`read()` method returns [onr::R](onr::R) reader structure"]
impl crate :: Readable for ONR { } # [doc = "`write(|w| ..)` method takes [onr::W](onr::W) writer structure"]
impl crate :: Writable for ONR { } # [doc = "ON Time Register"]
pub mod onr { # [doc = "Reader of register ONR"]
pub type R = crate :: R < u32 , super :: ONR > ; # [doc = "Writer for register ONR"]
pub type W = crate :: W < u32 , super :: ONR > ; # [doc = "Register ONR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: ONR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "OFF Time Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ofr](ofr) module"]
pub type OFR = crate :: Reg < u32 , _OFR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _OFR ; # [doc = "`read()` method returns [ofr::R](ofr::R) reader structure"]
impl crate :: Readable for OFR { } # [doc = "`write(|w| ..)` method takes [ofr::W](ofr::W) writer structure"]
impl crate :: Writable for OFR { } # [doc = "OFF Time Register"]
pub mod ofr { # [doc = "Reader of register OFR"]
pub type R = crate :: R < u32 , super :: OFR > ; # [doc = "Writer for register OFR"]
pub type W = crate :: W < u32 , super :: OFR > ; # [doc = "Register OFR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: OFR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r"All the peripherals"]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "LED_COMMON"]
pub LED_COMMON : LED_COMMON , } impl Peripherals { # [doc = r"Returns all the peripherals *once*"]
# [inline]
pub fn take () -> Option < Self > { riscv :: interrupt :: free (| _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some (unsafe { Peripherals :: steal () }) } }) } # [doc = r"Unchecked version of `Peripherals::take`"]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { LED_COMMON : LED_COMMON { _marker : PhantomData } , } } }
