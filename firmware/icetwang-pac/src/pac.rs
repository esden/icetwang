# ! [doc = "Peripheral access API for ICETWANG-SOC microcontrollers (generated using svd2rust v0.17.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.17.0/svd2rust/#peripheral-api"]
# ! [deny (const_err)]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
extern crate riscv ; # [cfg (feature = "rt")]
extern crate riscv_rt ; extern crate bare_metal ; extern crate vcell ; use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = "This trait shows that register has `read` method"]
# [doc = ""]
# [doc = "Registers marked with `Writable` can be also `modify`'ed"]
pub trait Readable { } # [doc = "This trait shows that register has `write`, `write_with_zero` and `reset` method"]
# [doc = ""]
# [doc = "Registers marked with `Readable` can be also `modify`'ed"]
pub trait Writable { } # [doc = "Reset value of the register"]
# [doc = ""]
# [doc = "This value is initial value for `write` method."]
# [doc = "It can be also directly writed to register by `reset` method."]
pub trait ResetValue { # [doc = "Register size"]
type Type ; # [doc = "Reset value of the register"]
fn reset_value () -> Self :: Type ; } # [doc = "This structure provides volatile access to register"]
pub struct Reg < U , REG > { register : vcell :: VolatileCell < U > , _marker : marker :: PhantomData < REG > , } unsafe impl < U : Send , REG > Send for Reg < U , REG > { } impl < U , REG > Reg < U , REG > where Self : Readable , U : Copy { # [doc = "Reads the contents of `Readable` register"]
# [doc = ""]
# [doc = "You can read the contents of a register in such way:"]
# [doc = "```ignore"]
# [doc = "let bits = periph.reg.read().bits();"]
# [doc = "```"]
# [doc = "or get the content of a particular field of a register."]
# [doc = "```ignore"]
# [doc = "let reader = periph.reg.read();"]
# [doc = "let bits = reader.field1().bits();"]
# [doc = "let flag = reader.field2().bit_is_set();"]
# [doc = "```"]
# [inline (always)]
pub fn read (& self) -> R < U , Self > { R { bits : self . register . get () , _reg : marker :: PhantomData } } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy , { # [doc = "Writes the reset value to `Writable` register"]
# [doc = ""]
# [doc = "Resets the register to its initial state"]
# [inline (always)]
pub fn reset (& self) { self . register . set (Self :: reset_value ()) } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy { # [doc = "Writes bits to `Writable` register"]
# [doc = ""]
# [doc = "You can write raw bits into a register:"]
# [doc = "```ignore"]
# [doc = "periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = "```"]
# [doc = "or write only the fields you need:"]
# [doc = "```ignore"]
# [doc = "periph.reg.write(|w| w"]
# [doc = "    .field1().bits(newfield1bits)"]
# [doc = "    .field2().set_bit()"]
# [doc = "    .field3().variant(VARIANT)"]
# [doc = ");"]
# [doc = "```"]
# [doc = "Other fields will have reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut W < U , Self >) -> & mut W < U , Self > { self . register . set (f (& mut W { bits : Self :: reset_value () , _reg : marker :: PhantomData }) . bits) ; } } impl < U , REG > Reg < U , REG > where Self : Writable , U : Copy + Default { # [doc = "Writes Zero to `Writable` register"]
# [doc = ""]
# [doc = "Similar to `write`, but unused bits will contain 0."]
# [inline (always)]
pub fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut W < U , Self >) -> & mut W < U , Self > { self . register . set (f (& mut W { bits : U :: default () , _reg : marker :: PhantomData }) . bits) ; } } impl < U , REG > Reg < U , REG > where Self : Readable + Writable , U : Copy , { # [doc = "Modifies the contents of the register"]
# [doc = ""]
# [doc = "E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = "```ignore"]
# [doc = "periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "   r.bits() | 3"]
# [doc = ") });"]
# [doc = "```"]
# [doc = "or"]
# [doc = "```ignore"]
# [doc = "periph.reg.modify(|_, w| w"]
# [doc = "    .field1().bits(newfield1bits)"]
# [doc = "    .field2().set_bit()"]
# [doc = "    .field3().variant(VARIANT)"]
# [doc = ");"]
# [doc = "```"]
# [doc = "Other fields will have value they had before call `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& R < U , Self > , & 'w mut W < U , Self >) -> & 'w mut W < U , Self > { let bits = self . register . get () ; self . register . set (f (& R { bits , _reg : marker :: PhantomData } , & mut W { bits , _reg : marker :: PhantomData }) . bits) ; } } # [doc = "Register/field reader"]
# [doc = ""]
# [doc = "Result of the [`read`](Reg::read) method of a register."]
# [doc = "Also it can be used in the [`modify`](Reg::read) method"]
pub struct R < U , T > { pub (crate) bits : U , _reg : marker :: PhantomData < T > , } impl < U , T > R < U , T > where U : Copy { # [doc = "Create new instance of reader"]
# [inline (always)]
pub (crate) fn new (bits : U) -> Self { Self { bits , _reg : marker :: PhantomData , } } # [doc = "Read raw bits from register/field"]
# [inline (always)]
pub fn bits (& self) -> U { self . bits } } impl < U , T , FI > PartialEq < FI > for R < U , T > where U : PartialEq , FI : Copy + Into < U > { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& (* other) . into ()) } } impl < FI > R < bool , FI > { # [doc = "Value of the field as raw bits"]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = "Returns `true` if the bit is clear (0)"]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = "Returns `true` if the bit is set (1)"]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc = "Register writer"]
# [doc = ""]
# [doc = "Used as an argument to the closures in the [`write`](Reg::write) and [`modify`](Reg::modify) methods of the register"]
pub struct W < U , REG > { # [doc = "Writable bits"]
pub (crate) bits : U , _reg : marker :: PhantomData < REG > , } impl < U , REG > W < U , REG > { # [doc = "Writes raw bits to the register"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : U) -> & mut Self { self . bits = bits ; self } } # [doc = "Used if enumerated values cover not the whole range"]
# [derive (Clone , Copy , PartialEq)]
pub enum Variant < U , T > { # [doc = "Expected variant"]
Val (T) , # [doc = "Raw bits"]
Res (U) , } } # [doc = "UART interface"]
pub struct UART { _marker : PhantomData < * const () > } unsafe impl Send for UART { } impl UART { # [doc = r"Returns a pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const uart :: RegisterBlock { 0x8100_0000 as * const _ } } impl Deref for UART { type Target = uart :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * UART :: ptr () } } } # [doc = "UART interface"]
pub mod uart { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - UART data in/out register. HSB 0 indicates pending data."]
pub data : DATA , # [doc = "0x04 - UART Config and Status Register"]
pub csr : CSR , } # [doc = "UART data in/out register. HSB 0 indicates pending data.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](data) module"]
pub type DATA = crate :: Reg < u32 , _DATA > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _DATA ; # [doc = "`read()` method returns [data::R](data::R) reader structure"]
impl crate :: Readable for DATA { } # [doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure"]
impl crate :: Writable for DATA { } # [doc = "UART data in/out register. HSB 0 indicates pending data."]
pub mod data { # [doc = "Reader of register DATA"]
pub type R = crate :: R < u32 , super :: DATA > ; # [doc = "Writer for register DATA"]
pub type W = crate :: W < u32 , super :: DATA > ; # [doc = "Register DATA `reset()`'s with value 0"]
impl crate :: ResetValue for super :: DATA { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `DATABYTE`"]
pub type DATABYTE_R = crate :: R < u8 , u8 > ; # [doc = "Write proxy for field `DATABYTE`"]
pub struct DATABYTE_W < 'a > { w : & 'a mut W , } impl < 'a > DATABYTE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0xff) | ((value as u32) & 0xff) ; self . w } } # [doc = "Reader of field `RFEMPTY`"]
pub type RFEMPTY_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `RFEMPTY`"]
pub struct RFEMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > RFEMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | (((value as u32) & 0x01) << 31) ; self . w } } impl R { # [doc = "Bits 0:7 - The actual data input and output."]
# [inline (always)]
pub fn databyte (& self) -> DATABYTE_R { DATABYTE_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bit 31 - Receive FIFO empty flag"]
# [inline (always)]
pub fn rfempty (& self) -> RFEMPTY_R { RFEMPTY_R :: new (((self . bits >> 31) & 0x01) != 0) } } impl W { # [doc = "Bits 0:7 - The actual data input and output."]
# [inline (always)]
pub fn databyte (& mut self) -> DATABYTE_W { DATABYTE_W { w : self } } # [doc = "Bit 31 - Receive FIFO empty flag"]
# [inline (always)]
pub fn rfempty (& mut self) -> RFEMPTY_W { RFEMPTY_W { w : self } } } } # [doc = "UART Config and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
pub type CSR = crate :: Reg < u32 , _CSR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _CSR ; # [doc = "`read()` method returns [csr::R](csr::R) reader structure"]
impl crate :: Readable for CSR { } # [doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
impl crate :: Writable for CSR { } # [doc = "UART Config and Status Register"]
pub mod csr { # [doc = "Reader of register CSR"]
pub type R = crate :: R < u32 , super :: CSR > ; # [doc = "Writer for register CSR"]
pub type W = crate :: W < u32 , super :: CSR > ; # [doc = "Register CSR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: CSR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `DIV`"]
pub type DIV_R = crate :: R < u16 , u16 > ; # [doc = "Write proxy for field `DIV`"]
pub struct DIV_W < 'a > { w : & 'a mut W , } impl < 'a > DIV_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u16) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x0fff) | ((value as u32) & 0x0fff) ; self . w } } # [doc = "Reader of field `TFFULL`"]
pub type TFFULL_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `TFFULL`"]
pub struct TFFULL_W < 'a > { w : & 'a mut W , } impl < 'a > TFFULL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 28)) | (((value as u32) & 0x01) << 28) ; self . w } } # [doc = "Reader of field `TFEMPTY`"]
pub type TFEMPTY_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `TFEMPTY`"]
pub struct TFEMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > TFEMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 29)) | (((value as u32) & 0x01) << 29) ; self . w } } # [doc = "Reader of field `RFOVERFLOW`"]
pub type RFOVERFLOW_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `RFOVERFLOW`"]
pub struct RFOVERFLOW_W < 'a > { w : & 'a mut W , } impl < 'a > RFOVERFLOW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 30)) | (((value as u32) & 0x01) << 30) ; self . w } } # [doc = "Reader of field `RFEMPTY`"]
pub type RFEMPTY_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `RFEMPTY`"]
pub struct RFEMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > RFEMPTY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | (((value as u32) & 0x01) << 31) ; self . w } } impl R { # [doc = "Bits 0:11 - Baud rate clock divider"]
# [inline (always)]
pub fn div (& self) -> DIV_R { DIV_R :: new ((self . bits & 0x0fff) as u16) } # [doc = "Bit 28 - Transmit FIFO full flag"]
# [inline (always)]
pub fn tffull (& self) -> TFFULL_R { TFFULL_R :: new (((self . bits >> 28) & 0x01) != 0) } # [doc = "Bit 29 - Transmit FIFO empty flag"]
# [inline (always)]
pub fn tfempty (& self) -> TFEMPTY_R { TFEMPTY_R :: new (((self . bits >> 29) & 0x01) != 0) } # [doc = "Bit 30 - Receive FIFO overflow flag"]
# [inline (always)]
pub fn rfoverflow (& self) -> RFOVERFLOW_R { RFOVERFLOW_R :: new (((self . bits >> 30) & 0x01) != 0) } # [doc = "Bit 31 - Receive FIFO empty flag"]
# [inline (always)]
pub fn rfempty (& self) -> RFEMPTY_R { RFEMPTY_R :: new (((self . bits >> 31) & 0x01) != 0) } } impl W { # [doc = "Bits 0:11 - Baud rate clock divider"]
# [inline (always)]
pub fn div (& mut self) -> DIV_W { DIV_W { w : self } } # [doc = "Bit 28 - Transmit FIFO full flag"]
# [inline (always)]
pub fn tffull (& mut self) -> TFFULL_W { TFFULL_W { w : self } } # [doc = "Bit 29 - Transmit FIFO empty flag"]
# [inline (always)]
pub fn tfempty (& mut self) -> TFEMPTY_W { TFEMPTY_W { w : self } } # [doc = "Bit 30 - Receive FIFO overflow flag"]
# [inline (always)]
pub fn rfoverflow (& mut self) -> RFOVERFLOW_W { RFOVERFLOW_W { w : self } } # [doc = "Bit 31 - Receive FIFO empty flag"]
# [inline (always)]
pub fn rfempty (& mut self) -> RFEMPTY_W { RFEMPTY_W { w : self } } } } } # [doc = "RGBLED control"]
pub struct RGBLED { _marker : PhantomData < * const () > } unsafe impl Send for RGBLED { } impl RGBLED { # [doc = r"Returns a pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const rgbled :: RegisterBlock { 0x8300_0000 as * const _ } } impl Deref for RGBLED { type Target = rgbled :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * RGBLED :: ptr () } } } # [doc = "RGBLED control"]
pub mod rgbled { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control and Status Register"]
pub csr : CSR , _reserved1 : [u8 ; 64usize]
, # [doc = "0x44 - Pulse Width Register Red"]
pub pwrr : PWRR , # [doc = "0x48 - Pulse Width Register Green"]
pub pwrg : PWRG , # [doc = "0x4c - Pulse Width Register Blue"]
pub pwrb : PWRB , _reserved4 : [u8 ; 4usize]
, # [doc = "0x54 - Breathe Control Rise Register"]
pub bcrr : BCRR , # [doc = "0x58 - Breathe Control Fall Register"]
pub bcfr : BCFR , _reserved6 : [u8 ; 4usize]
, # [doc = "0x60 - Control Register 0"]
pub cr0 : CR0 , # [doc = "0x64 - Pre-scale Register"]
pub br : BR , # [doc = "0x68 - ON Time Register"]
pub onr : ONR , # [doc = "0x6c - OFF Time Register"]
pub ofr : OFR , } # [doc = "Control and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
pub type CSR = crate :: Reg < u32 , _CSR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _CSR ; # [doc = "`read()` method returns [csr::R](csr::R) reader structure"]
impl crate :: Readable for CSR { } # [doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
impl crate :: Writable for CSR { } # [doc = "Control and Status Register"]
pub mod csr { # [doc = "Reader of register CSR"]
pub type R = crate :: R < u32 , super :: CSR > ; # [doc = "Writer for register CSR"]
pub type W = crate :: W < u32 , super :: CSR > ; # [doc = "Register CSR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: CSR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `LEDDEXE`"]
pub type LEDDEXE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `LEDDEXE`"]
pub struct LEDDEXE_W < 'a > { w : & 'a mut W , } impl < 'a > LEDDEXE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | (((value as u32) & 0x01) << 1) ; self . w } } # [doc = "Reader of field `RGBLEDEN`"]
pub type RGBLEDEN_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `RGBLEDEN`"]
pub struct RGBLEDEN_W < 'a > { w : & 'a mut W , } impl < 'a > RGBLEDEN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | (((value as u32) & 0x01) << 2) ; self . w } } # [doc = "Reader of field `CURREN`"]
pub type CURREN_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `CURREN`"]
pub struct CURREN_W < 'a > { w : & 'a mut W , } impl < 'a > CURREN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | (((value as u32) & 0x01) << 3) ; self . w } } impl R { # [doc = "Bit 1 - Enable the IP to run the blinking sequence. When low, the sequence stops at the nearest OFF state"]
# [inline (always)]
pub fn leddexe (& self) -> LEDDEXE_R { LEDDEXE_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Enable control of the RGB LED"]
# [inline (always)]
pub fn rgbleden (& self) -> RGBLEDEN_R { RGBLEDEN_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Power up"]
# [inline (always)]
pub fn curren (& self) -> CURREN_R { CURREN_R :: new (((self . bits >> 3) & 0x01) != 0) } } impl W { # [doc = "Bit 1 - Enable the IP to run the blinking sequence. When low, the sequence stops at the nearest OFF state"]
# [inline (always)]
pub fn leddexe (& mut self) -> LEDDEXE_W { LEDDEXE_W { w : self } } # [doc = "Bit 2 - Enable control of the RGB LED"]
# [inline (always)]
pub fn rgbleden (& mut self) -> RGBLEDEN_W { RGBLEDEN_W { w : self } } # [doc = "Bit 3 - Power up"]
# [inline (always)]
pub fn curren (& mut self) -> CURREN_W { CURREN_W { w : self } } } } # [doc = "Pulse Width Register Red\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pwrr](pwrr) module"]
pub type PWRR = crate :: Reg < u32 , _PWRR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _PWRR ; # [doc = "`read()` method returns [pwrr::R](pwrr::R) reader structure"]
impl crate :: Readable for PWRR { } # [doc = "`write(|w| ..)` method takes [pwrr::W](pwrr::W) writer structure"]
impl crate :: Writable for PWRR { } # [doc = "Pulse Width Register Red"]
pub mod pwrr { # [doc = "Reader of register PWRR"]
pub type R = crate :: R < u32 , super :: PWRR > ; # [doc = "Writer for register PWRR"]
pub type W = crate :: W < u32 , super :: PWRR > ; # [doc = "Register PWRR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: PWRR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "Pulse Width Register Green\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pwrg](pwrg) module"]
pub type PWRG = crate :: Reg < u32 , _PWRG > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _PWRG ; # [doc = "`read()` method returns [pwrg::R](pwrg::R) reader structure"]
impl crate :: Readable for PWRG { } # [doc = "`write(|w| ..)` method takes [pwrg::W](pwrg::W) writer structure"]
impl crate :: Writable for PWRG { } # [doc = "Pulse Width Register Green"]
pub mod pwrg { # [doc = "Reader of register PWRG"]
pub type R = crate :: R < u32 , super :: PWRG > ; # [doc = "Writer for register PWRG"]
pub type W = crate :: W < u32 , super :: PWRG > ; # [doc = "Register PWRG `reset()`'s with value 0"]
impl crate :: ResetValue for super :: PWRG { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "Pulse Width Register Blue\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pwrb](pwrb) module"]
pub type PWRB = crate :: Reg < u32 , _PWRB > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _PWRB ; # [doc = "`read()` method returns [pwrb::R](pwrb::R) reader structure"]
impl crate :: Readable for PWRB { } # [doc = "`write(|w| ..)` method takes [pwrb::W](pwrb::W) writer structure"]
impl crate :: Writable for PWRB { } # [doc = "Pulse Width Register Blue"]
pub mod pwrb { # [doc = "Reader of register PWRB"]
pub type R = crate :: R < u32 , super :: PWRB > ; # [doc = "Writer for register PWRB"]
pub type W = crate :: W < u32 , super :: PWRB > ; # [doc = "Register PWRB `reset()`'s with value 0"]
impl crate :: ResetValue for super :: PWRB { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "Breathe Control Rise Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bcrr](bcrr) module"]
pub type BCRR = crate :: Reg < u32 , _BCRR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _BCRR ; # [doc = "`read()` method returns [bcrr::R](bcrr::R) reader structure"]
impl crate :: Readable for BCRR { } # [doc = "`write(|w| ..)` method takes [bcrr::W](bcrr::W) writer structure"]
impl crate :: Writable for BCRR { } # [doc = "Breathe Control Rise Register"]
pub mod bcrr { # [doc = "Reader of register BCRR"]
pub type R = crate :: R < u32 , super :: BCRR > ; # [doc = "Writer for register BCRR"]
pub type W = crate :: W < u32 , super :: BCRR > ; # [doc = "Register BCRR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: BCRR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `BRATE`"]
pub type BRATE_R = crate :: R < u8 , u8 > ; # [doc = "Write proxy for field `BRATE`"]
pub struct BRATE_W < 'a > { w : & 'a mut W , } impl < 'a > BRATE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x0f) | ((value as u32) & 0x0f) ; self . w } } # [doc = "Reader of field `BMODE`"]
pub type BMODE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BMODE`"]
pub struct BMODE_W < 'a > { w : & 'a mut W , } impl < 'a > BMODE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | (((value as u32) & 0x01) << 5) ; self . w } } # [doc = "Reader of field `BEDGE`"]
pub type BEDGE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BEDGE`"]
pub struct BEDGE_W < 'a > { w : & 'a mut W , } impl < 'a > BEDGE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | (((value as u32) & 0x01) << 6) ; self . w } } # [doc = "Reader of field `BON`"]
pub type BON_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BON`"]
pub struct BON_W < 'a > { w : & 'a mut W , } impl < 'a > BON_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | (((value as u32) & 0x01) << 7) ; self . w } } impl R { # [doc = "Bits 0:3 - Breathe ON Rate"]
# [inline (always)]
pub fn brate (& self) -> BRATE_R { BRATE_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 5 - Breathe Mode Select 0= Breathe with local rate, 1= Modulate rate based on color setting"]
# [inline (always)]
pub fn bmode (& self) -> BMODE_R { BMODE_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - Breathe Edge 0= Breathe control only for ON ramp, 1= Breathe control for ON and OFF ramp"]
# [inline (always)]
pub fn bedge (& self) -> BEDGE_R { BEDGE_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Breathe ON Enable"]
# [inline (always)]
pub fn bon (& self) -> BON_R { BON_R :: new (((self . bits >> 7) & 0x01) != 0) } } impl W { # [doc = "Bits 0:3 - Breathe ON Rate"]
# [inline (always)]
pub fn brate (& mut self) -> BRATE_W { BRATE_W { w : self } } # [doc = "Bit 5 - Breathe Mode Select 0= Breathe with local rate, 1= Modulate rate based on color setting"]
# [inline (always)]
pub fn bmode (& mut self) -> BMODE_W { BMODE_W { w : self } } # [doc = "Bit 6 - Breathe Edge 0= Breathe control only for ON ramp, 1= Breathe control for ON and OFF ramp"]
# [inline (always)]
pub fn bedge (& mut self) -> BEDGE_W { BEDGE_W { w : self } } # [doc = "Bit 7 - Breathe ON Enable"]
# [inline (always)]
pub fn bon (& mut self) -> BON_W { BON_W { w : self } } } } # [doc = "Breathe Control Fall Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bcfr](bcfr) module"]
pub type BCFR = crate :: Reg < u32 , _BCFR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _BCFR ; # [doc = "`read()` method returns [bcfr::R](bcfr::R) reader structure"]
impl crate :: Readable for BCFR { } # [doc = "`write(|w| ..)` method takes [bcfr::W](bcfr::W) writer structure"]
impl crate :: Writable for BCFR { } # [doc = "Breathe Control Fall Register"]
pub mod bcfr { # [doc = "Reader of register BCFR"]
pub type R = crate :: R < u32 , super :: BCFR > ; # [doc = "Writer for register BCFR"]
pub type W = crate :: W < u32 , super :: BCFR > ; # [doc = "Register BCFR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: BCFR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `BRATE`"]
pub type BRATE_R = crate :: R < u8 , u8 > ; # [doc = "Write proxy for field `BRATE`"]
pub struct BRATE_W < 'a > { w : & 'a mut W , } impl < 'a > BRATE_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x0f) | ((value as u32) & 0x0f) ; self . w } } # [doc = "Reader of field `BMODE`"]
pub type BMODE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BMODE`"]
pub struct BMODE_W < 'a > { w : & 'a mut W , } impl < 'a > BMODE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | (((value as u32) & 0x01) << 5) ; self . w } } # [doc = "Reader of field `BRANGE`"]
pub type BRANGE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BRANGE`"]
pub struct BRANGE_W < 'a > { w : & 'a mut W , } impl < 'a > BRANGE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | (((value as u32) & 0x01) << 6) ; self . w } } # [doc = "Reader of field `BON`"]
pub type BON_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BON`"]
pub struct BON_W < 'a > { w : & 'a mut W , } impl < 'a > BON_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | (((value as u32) & 0x01) << 7) ; self . w } } impl R { # [doc = "Bits 0:3 - Breathe OFF Rate"]
# [inline (always)]
pub fn brate (& self) -> BRATE_R { BRATE_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 5 - Breathe Mode Select 0= Breathe with local rate, 1= Modulate rate based on color setting"]
# [inline (always)]
pub fn bmode (& self) -> BMODE_R { BMODE_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - Breathe Range extend for linear mode"]
# [inline (always)]
pub fn brange (& self) -> BRANGE_R { BRANGE_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - Breathe OFF Enable"]
# [inline (always)]
pub fn bon (& self) -> BON_R { BON_R :: new (((self . bits >> 7) & 0x01) != 0) } } impl W { # [doc = "Bits 0:3 - Breathe OFF Rate"]
# [inline (always)]
pub fn brate (& mut self) -> BRATE_W { BRATE_W { w : self } } # [doc = "Bit 5 - Breathe Mode Select 0= Breathe with local rate, 1= Modulate rate based on color setting"]
# [inline (always)]
pub fn bmode (& mut self) -> BMODE_W { BMODE_W { w : self } } # [doc = "Bit 6 - Breathe Range extend for linear mode"]
# [inline (always)]
pub fn brange (& mut self) -> BRANGE_W { BRANGE_W { w : self } } # [doc = "Bit 7 - Breathe OFF Enable"]
# [inline (always)]
pub fn bon (& mut self) -> BON_W { BON_W { w : self } } } } # [doc = "Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr0](cr0) module"]
pub type CR0 = crate :: Reg < u32 , _CR0 > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _CR0 ; # [doc = "`read()` method returns [cr0::R](cr0::R) reader structure"]
impl crate :: Readable for CR0 { } # [doc = "`write(|w| ..)` method takes [cr0::W](cr0::W) writer structure"]
impl crate :: Writable for CR0 { } # [doc = "Control Register 0"]
pub mod cr0 { # [doc = "Reader of register CR0"]
pub type R = crate :: R < u32 , super :: CR0 > ; # [doc = "Writer for register CR0"]
pub type W = crate :: W < u32 , super :: CR0 > ; # [doc = "Register CR0 `reset()`'s with value 0"]
impl crate :: ResetValue for super :: CR0 { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `BRMSBEXT`"]
pub type BRMSBEXT_R = crate :: R < u8 , u8 > ; # [doc = "Write proxy for field `BRMSBEXT`"]
pub struct BRMSBEXT_W < 'a > { w : & 'a mut W , } impl < 'a > BRMSBEXT_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x03) | ((value as u32) & 0x03) ; self . w } } # [doc = "Reader of field `PWM_MODE`"]
pub type PWM_MODE_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `PWM_MODE`"]
pub struct PWM_MODE_W < 'a > { w : & 'a mut W , } impl < 'a > PWM_MODE_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | (((value as u32) & 0x01) << 2) ; self . w } } # [doc = "Reader of field `QUICK_STOP`"]
pub type QUICK_STOP_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `QUICK_STOP`"]
pub struct QUICK_STOP_W < 'a > { w : & 'a mut W , } impl < 'a > QUICK_STOP_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | (((value as u32) & 0x01) << 3) ; self . w } } # [doc = "Reader of field `OUTSKEW`"]
pub type OUTSKEW_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `OUTSKEW`"]
pub struct OUTSKEW_W < 'a > { w : & 'a mut W , } impl < 'a > OUTSKEW_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 4)) | (((value as u32) & 0x01) << 4) ; self . w } } # [doc = "Reader of field `OUTPOL`"]
pub type OUTPOL_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `OUTPOL`"]
pub struct OUTPOL_W < 'a > { w : & 'a mut W , } impl < 'a > OUTPOL_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 5)) | (((value as u32) & 0x01) << 5) ; self . w } } # [doc = "Reader of field `FR250`"]
pub type FR250_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `FR250`"]
pub struct FR250_W < 'a > { w : & 'a mut W , } impl < 'a > FR250_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 6)) | (((value as u32) & 0x01) << 6) ; self . w } } # [doc = "Reader of field `LEDDEN`"]
pub type LEDDEN_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `LEDDEN`"]
pub struct LEDDEN_W < 'a > { w : & 'a mut W , } impl < 'a > LEDDEN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 7)) | (((value as u32) & 0x01) << 7) ; self . w } } impl R { # [doc = "Bits 0:1 - Pre-scale register MSB extension"]
# [inline (always)]
pub fn brmsbext (& self) -> BRMSBEXT_R { BRMSBEXT_R :: new ((self . bits & 0x03) as u8) } # [doc = "Bit 2 - 0= Linear, 1= LFSR"]
# [inline (always)]
pub fn pwm_mode (& self) -> PWM_MODE_R { PWM_MODE_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - 0= Stop the blinking sequence wheen current ON period finishes, 1= Stop blinking immediately"]
# [inline (always)]
pub fn quick_stop (& self) -> QUICK_STOP_R { QUICK_STOP_R :: new (((self . bits >> 3) & 0x01) != 0) } # [doc = "Bit 4 - Enable PWM slew to reduce simultaneous switching noise, based on BRMSBEXT"]
# [inline (always)]
pub fn outskew (& self) -> OUTSKEW_R { OUTSKEW_R :: new (((self . bits >> 4) & 0x01) != 0) } # [doc = "Bit 5 - PWM output polarity. 0= Active high, 1= Active low"]
# [inline (always)]
pub fn outpol (& self) -> OUTPOL_R { OUTPOL_R :: new (((self . bits >> 5) & 0x01) != 0) } # [doc = "Bit 6 - PWM flick rate. 0= 125Hz, 1= 250Hz"]
# [inline (always)]
pub fn fr250 (& self) -> FR250_R { FR250_R :: new (((self . bits >> 6) & 0x01) != 0) } # [doc = "Bit 7 - LED Driver Enable"]
# [inline (always)]
pub fn ledden (& self) -> LEDDEN_R { LEDDEN_R :: new (((self . bits >> 7) & 0x01) != 0) } } impl W { # [doc = "Bits 0:1 - Pre-scale register MSB extension"]
# [inline (always)]
pub fn brmsbext (& mut self) -> BRMSBEXT_W { BRMSBEXT_W { w : self } } # [doc = "Bit 2 - 0= Linear, 1= LFSR"]
# [inline (always)]
pub fn pwm_mode (& mut self) -> PWM_MODE_W { PWM_MODE_W { w : self } } # [doc = "Bit 3 - 0= Stop the blinking sequence wheen current ON period finishes, 1= Stop blinking immediately"]
# [inline (always)]
pub fn quick_stop (& mut self) -> QUICK_STOP_W { QUICK_STOP_W { w : self } } # [doc = "Bit 4 - Enable PWM slew to reduce simultaneous switching noise, based on BRMSBEXT"]
# [inline (always)]
pub fn outskew (& mut self) -> OUTSKEW_W { OUTSKEW_W { w : self } } # [doc = "Bit 5 - PWM output polarity. 0= Active high, 1= Active low"]
# [inline (always)]
pub fn outpol (& mut self) -> OUTPOL_W { OUTPOL_W { w : self } } # [doc = "Bit 6 - PWM flick rate. 0= 125Hz, 1= 250Hz"]
# [inline (always)]
pub fn fr250 (& mut self) -> FR250_W { FR250_W { w : self } } # [doc = "Bit 7 - LED Driver Enable"]
# [inline (always)]
pub fn ledden (& mut self) -> LEDDEN_W { LEDDEN_W { w : self } } } } # [doc = "Pre-scale Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [br](br) module"]
pub type BR = crate :: Reg < u32 , _BR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _BR ; # [doc = "`read()` method returns [br::R](br::R) reader structure"]
impl crate :: Readable for BR { } # [doc = "`write(|w| ..)` method takes [br::W](br::W) writer structure"]
impl crate :: Writable for BR { } # [doc = "Pre-scale Register"]
pub mod br { # [doc = "Reader of register BR"]
pub type R = crate :: R < u32 , super :: BR > ; # [doc = "Writer for register BR"]
pub type W = crate :: W < u32 , super :: BR > ; # [doc = "Register BR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: BR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "ON Time Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [onr](onr) module"]
pub type ONR = crate :: Reg < u32 , _ONR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _ONR ; # [doc = "`read()` method returns [onr::R](onr::R) reader structure"]
impl crate :: Readable for ONR { } # [doc = "`write(|w| ..)` method takes [onr::W](onr::W) writer structure"]
impl crate :: Writable for ONR { } # [doc = "ON Time Register"]
pub mod onr { # [doc = "Reader of register ONR"]
pub type R = crate :: R < u32 , super :: ONR > ; # [doc = "Writer for register ONR"]
pub type W = crate :: W < u32 , super :: ONR > ; # [doc = "Register ONR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: ONR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "OFF Time Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ofr](ofr) module"]
pub type OFR = crate :: Reg < u32 , _OFR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _OFR ; # [doc = "`read()` method returns [ofr::R](ofr::R) reader structure"]
impl crate :: Readable for OFR { } # [doc = "`write(|w| ..)` method takes [ofr::W](ofr::W) writer structure"]
impl crate :: Writable for OFR { } # [doc = "OFF Time Register"]
pub mod ofr { # [doc = "Reader of register OFR"]
pub type R = crate :: R < u32 , super :: OFR > ; # [doc = "Writer for register OFR"]
pub type W = crate :: W < u32 , super :: OFR > ; # [doc = "Register OFR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: OFR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } } # [doc = "RGB LED string interface"]
pub struct LEDSTR { _marker : PhantomData < * const () > } unsafe impl Send for LEDSTR { } impl LEDSTR { # [doc = r"Returns a pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ledstr :: RegisterBlock { 0x8600_0000 as * const _ } } impl Deref for LEDSTR { type Target = ledstr :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * LEDSTR :: ptr () } } } # [doc = "RGB LED string interface"]
pub mod ledstr { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control and Status Register"]
pub csr : CSR , # [doc = "0x04 - Global LED string brightness"]
pub glob : GLOB , } # [doc = "Control and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
pub type CSR = crate :: Reg < u32 , _CSR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _CSR ; # [doc = "`read()` method returns [csr::R](csr::R) reader structure"]
impl crate :: Readable for CSR { } # [doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
impl crate :: Writable for CSR { } # [doc = "Control and Status Register"]
pub mod csr { # [doc = "Reader of register CSR"]
pub type R = crate :: R < u32 , super :: CSR > ; # [doc = "Writer for register CSR"]
pub type W = crate :: W < u32 , super :: CSR > ; # [doc = "Register CSR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: CSR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `DIV`"]
pub type DIV_R = crate :: R < u16 , u16 > ; # [doc = "Write proxy for field `DIV`"]
pub struct DIV_W < 'a > { w : & 'a mut W , } impl < 'a > DIV_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u16) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0xffff) | ((value as u32) & 0xffff) ; self . w } } # [doc = "Reader of field `LEN`"]
pub type LEN_R = crate :: R < u16 , u16 > ; # [doc = "Write proxy for field `LEN`"]
pub struct LEN_W < 'a > { w : & 'a mut W , } impl < 'a > LEN_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u16) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01ff << 16)) | (((value as u32) & 0x01ff) << 16) ; self . w } } # [doc = "Reader of field `BSY`"]
pub type BSY_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `BSY`"]
pub struct BSY_W < 'a > { w : & 'a mut W , } impl < 'a > BSY_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 30)) | (((value as u32) & 0x01) << 30) ; self . w } } # [doc = "Reader of field `STRT`"]
pub type STRT_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `STRT`"]
pub struct STRT_W < 'a > { w : & 'a mut W , } impl < 'a > STRT_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 31)) | (((value as u32) & 0x01) << 31) ; self . w } } impl R { # [doc = "Bits 0:15 - Clock divider"]
# [inline (always)]
pub fn div (& self) -> DIV_R { DIV_R :: new ((self . bits & 0xffff) as u16) } # [doc = "Bits 16:24 - LED String Length"]
# [inline (always)]
pub fn len (& self) -> LEN_R { LEN_R :: new (((self . bits >> 16) & 0x01ff) as u16) } # [doc = "Bit 30 - Reads 0 when idle and 1 when transmitting LED data"]
# [inline (always)]
pub fn bsy (& self) -> BSY_R { BSY_R :: new (((self . bits >> 30) & 0x01) != 0) } # [doc = "Bit 31 - Write 1 to start LED string data transmission"]
# [inline (always)]
pub fn strt (& self) -> STRT_R { STRT_R :: new (((self . bits >> 31) & 0x01) != 0) } } impl W { # [doc = "Bits 0:15 - Clock divider"]
# [inline (always)]
pub fn div (& mut self) -> DIV_W { DIV_W { w : self } } # [doc = "Bits 16:24 - LED String Length"]
# [inline (always)]
pub fn len (& mut self) -> LEN_W { LEN_W { w : self } } # [doc = "Bit 30 - Reads 0 when idle and 1 when transmitting LED data"]
# [inline (always)]
pub fn bsy (& mut self) -> BSY_W { BSY_W { w : self } } # [doc = "Bit 31 - Write 1 to start LED string data transmission"]
# [inline (always)]
pub fn strt (& mut self) -> STRT_W { STRT_W { w : self } } } } # [doc = "Global LED string brightness\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [glob](glob) module"]
pub type GLOB = crate :: Reg < u32 , _GLOB > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _GLOB ; # [doc = "`read()` method returns [glob::R](glob::R) reader structure"]
impl crate :: Readable for GLOB { } # [doc = "`write(|w| ..)` method takes [glob::W](glob::W) writer structure"]
impl crate :: Writable for GLOB { } # [doc = "Global LED string brightness"]
pub mod glob { # [doc = "Reader of register GLOB"]
pub type R = crate :: R < u32 , super :: GLOB > ; # [doc = "Writer for register GLOB"]
pub type W = crate :: W < u32 , super :: GLOB > ; # [doc = "Register GLOB `reset()`'s with value 0x1f"]
impl crate :: ResetValue for super :: GLOB { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0x1f } } # [doc = "Reader of field `GLOB`"]
pub type GLOB_R = crate :: R < u8 , u8 > ; # [doc = "Write proxy for field `GLOB`"]
pub struct GLOB_W < 'a > { w : & 'a mut W , } impl < 'a > GLOB_W < 'a > { # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub unsafe fn bits (self , value : u8) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x1f) | ((value as u32) & 0x1f) ; self . w } } impl R { # [doc = "Bits 0:4 - Global LED string brightness"]
# [inline (always)]
pub fn glob (& self) -> GLOB_R { GLOB_R :: new ((self . bits & 0x1f) as u8) } } impl W { # [doc = "Bits 0:4 - Global LED string brightness"]
# [inline (always)]
pub fn glob (& mut self) -> GLOB_W { GLOB_W { w : self } } } } } # [doc = "TIMER"]
pub struct TIMER { _marker : PhantomData < * const () > } unsafe impl Send for TIMER { } impl TIMER { # [doc = r"Returns a pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer :: RegisterBlock { 0x8700_0000 as * const _ } } impl Deref for TIMER { type Target = timer :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * TIMER :: ptr () } } } # [doc = "TIMER"]
pub mod timer { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control and Status Register"]
pub csr : CSR , # [doc = "0x04 - Value loaded into the timer counter when EN goes high"]
pub load : LOAD , # [doc = "0x08 - Value loaded into the timer counter when timer reaches 0"]
pub reload : RELOAD , # [doc = "0x0c - Live timer counter value"]
pub counter : COUNTER , } # [doc = "Control and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
pub type CSR = crate :: Reg < u32 , _CSR > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _CSR ; # [doc = "`read()` method returns [csr::R](csr::R) reader structure"]
impl crate :: Readable for CSR { } # [doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
impl crate :: Writable for CSR { } # [doc = "Control and Status Register"]
pub mod csr { # [doc = "Reader of register CSR"]
pub type R = crate :: R < u32 , super :: CSR > ; # [doc = "Writer for register CSR"]
pub type W = crate :: W < u32 , super :: CSR > ; # [doc = "Register CSR `reset()`'s with value 0"]
impl crate :: ResetValue for super :: CSR { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } # [doc = "Reader of field `EN`"]
pub type EN_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `EN`"]
pub struct EN_W < 'a > { w : & 'a mut W , } impl < 'a > EN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! 0x01) | ((value as u32) & 0x01) ; self . w } } # [doc = "Reader of field `ST`"]
pub type ST_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `ST`"]
pub struct ST_W < 'a > { w : & 'a mut W , } impl < 'a > ST_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 1)) | (((value as u32) & 0x01) << 1) ; self . w } } # [doc = "Reader of field `EV`"]
pub type EV_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `EV`"]
pub struct EV_W < 'a > { w : & 'a mut W , } impl < 'a > EV_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 2)) | (((value as u32) & 0x01) << 2) ; self . w } } # [doc = "Reader of field `EV_EN`"]
pub type EV_EN_R = crate :: R < bool , bool > ; # [doc = "Write proxy for field `EV_EN`"]
pub struct EV_EN_W < 'a > { w : & 'a mut W , } impl < 'a > EV_EN_W < 'a > { # [doc = r"Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W { self . bit (true) } # [doc = r"Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W { self . bit (false) } # [doc = r"Writes raw bits to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> & 'a mut W { self . w . bits = (self . w . bits & ! (0x01 << 3)) | (((value as u32) & 0x01) << 3) ; self . w } } impl R { # [doc = "Bit 0 - Timer enable"]
# [inline (always)]
pub fn en (& self) -> EN_R { EN_R :: new ((self . bits & 0x01) != 0) } # [doc = "Bit 1 - Timer status, 1 while timer is != 0"]
# [inline (always)]
pub fn st (& self) -> ST_R { ST_R :: new (((self . bits >> 1) & 0x01) != 0) } # [doc = "Bit 2 - Timer event, set to 1 when timer reaches 0 and EV_EN is set"]
# [inline (always)]
pub fn ev (& self) -> EV_R { EV_R :: new (((self . bits >> 2) & 0x01) != 0) } # [doc = "Bit 3 - Timer event enable"]
# [inline (always)]
pub fn ev_en (& self) -> EV_EN_R { EV_EN_R :: new (((self . bits >> 3) & 0x01) != 0) } } impl W { # [doc = "Bit 0 - Timer enable"]
# [inline (always)]
pub fn en (& mut self) -> EN_W { EN_W { w : self } } # [doc = "Bit 1 - Timer status, 1 while timer is != 0"]
# [inline (always)]
pub fn st (& mut self) -> ST_W { ST_W { w : self } } # [doc = "Bit 2 - Timer event, set to 1 when timer reaches 0 and EV_EN is set"]
# [inline (always)]
pub fn ev (& mut self) -> EV_W { EV_W { w : self } } # [doc = "Bit 3 - Timer event enable"]
# [inline (always)]
pub fn ev_en (& mut self) -> EV_EN_W { EV_EN_W { w : self } } } } # [doc = "Value loaded into the timer counter when EN goes high\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [load](load) module"]
pub type LOAD = crate :: Reg < u32 , _LOAD > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _LOAD ; # [doc = "`read()` method returns [load::R](load::R) reader structure"]
impl crate :: Readable for LOAD { } # [doc = "`write(|w| ..)` method takes [load::W](load::W) writer structure"]
impl crate :: Writable for LOAD { } # [doc = "Value loaded into the timer counter when EN goes high"]
pub mod load { # [doc = "Reader of register LOAD"]
pub type R = crate :: R < u32 , super :: LOAD > ; # [doc = "Writer for register LOAD"]
pub type W = crate :: W < u32 , super :: LOAD > ; # [doc = "Register LOAD `reset()`'s with value 0"]
impl crate :: ResetValue for super :: LOAD { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "Value loaded into the timer counter when timer reaches 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reload](reload) module"]
pub type RELOAD = crate :: Reg < u32 , _RELOAD > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _RELOAD ; # [doc = "`read()` method returns [reload::R](reload::R) reader structure"]
impl crate :: Readable for RELOAD { } # [doc = "`write(|w| ..)` method takes [reload::W](reload::W) writer structure"]
impl crate :: Writable for RELOAD { } # [doc = "Value loaded into the timer counter when timer reaches 0"]
pub mod reload { # [doc = "Reader of register RELOAD"]
pub type R = crate :: R < u32 , super :: RELOAD > ; # [doc = "Writer for register RELOAD"]
pub type W = crate :: W < u32 , super :: RELOAD > ; # [doc = "Register RELOAD `reset()`'s with value 0"]
impl crate :: ResetValue for super :: RELOAD { type Type = u32 ; # [inline (always)]
fn reset_value () -> Self :: Type { 0 } } impl R { } impl W { } } # [doc = "Live timer counter value\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [counter](counter) module"]
pub type COUNTER = crate :: Reg < u32 , _COUNTER > ; # [allow (missing_docs)]
# [doc (hidden)]
pub struct _COUNTER ; # [doc = "`read()` method returns [counter::R](counter::R) reader structure"]
impl crate :: Readable for COUNTER { } # [doc = "Live timer counter value"]
pub mod counter { # [doc = "Reader of register COUNTER"]
pub type R = crate :: R < u32 , super :: COUNTER > ; impl R { } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r"All the peripherals"]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "UART"]
pub UART : UART , # [doc = "RGBLED"]
pub RGBLED : RGBLED , # [doc = "LEDSTR"]
pub LEDSTR : LEDSTR , # [doc = "TIMER"]
pub TIMER : TIMER , } impl Peripherals { # [doc = r"Returns all the peripherals *once*"]
# [inline]
pub fn take () -> Option < Self > { riscv :: interrupt :: free (| _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some (unsafe { Peripherals :: steal () }) } }) } # [doc = r"Unchecked version of `Peripherals::take`"]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { UART : UART { _marker : PhantomData } , RGBLED : RGBLED { _marker : PhantomData } , LEDSTR : LEDSTR { _marker : PhantomData } , TIMER : TIMER { _marker : PhantomData } , } } }
